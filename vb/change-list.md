# Change List

The following sections list of changes made to the specification between versions. The sections affected are listed after each change.

## Version 7.1 to Version 8.0

This update covers the language changes made between version 7.1 of the language and version 8.0 of the language.

### Major changes

1. Multiple attribute blocks are now allowed before a declaration (i.e. `<a> <b>` instead of just `<a,b>`). [5.2, 6]
2. Added the `Continue` statement. [2.3, 10.11]
3. Added the `Using` statement. [2.3, 10, 10.13]
4. Added the `IsNot` operator. [2.3, 11.5.3]
5. Added the `Global` qualifier which allows binding in the global namespace. [2.3, 4.7, 11.6]
6. Added XML Documentation comments. [12]
7. Derived classes are allowed to re-implement interfaces implemented by their base class. [4.4, 4.4.1]
8. Added the `TryCast` operator. [2.3, 11.11]
9. Attributes can have arguments typed as `Object` or one-dimensional arrays. [5.1, 5.2.2]
10. Added a section on language compatibility [1.2, 1.2.1, 1.2.2, 1.2.3]
11. Added operator overloading. [2.3, 4.1.1, 7.5.2, 7.6.1, 9.8, 9.8.1, 9.8.2, 9.8.3, 10.8.2, 10.9.2, 11.17.1, 11.11, 8.11, 8.11.1, 8.11.2, 11.12.3]
12. Added pseudo operators `IsTrue` and `IsFalse`. [11.19, 10.8.1, 10.9.1, 10.10.1.2]
13. Added unsigned integer types. [2.2.1, 2.3, 2.4.2, 7.3, 11.11, 7.4, 8.2, 8.3, 8.7, 8.8, 8.9, 10.9.2, 11.2, 11.12.3, 11.13.1, 11.13.2, 11.13.3, 11.13.4, 11.13.5, 11.13.6, 11.13.7, 11.13.8, 11.14, 11.15, 11.16, 11.17, 11.17.1, 11.18, 11.8.1]
14. Added custom event declarations. [9.4.1]
15. Property accessors can specify a more restrictive access level than their containing property. [9.7, 9.7.1, 9.7.2, 9.7.3]
16. Added partial types. [2.3, 7.5, 7.6, 7.11]
17. Added default instances. [11.6.2, 11.6.2.1, 11.6.2.2]
18. Added generic types and methods. [2.3, 2.4.7, 4.1.1, 4.4.1, 4.5.1, 4.6, 4.7.1, 4.7.2, 4.9, 4.9.1, 4.9.2, 5.1, 5.2.2, 6.1, 6.3.1, 6.3.2, 7, 7.2, 7.5, 7.5.1, 7.6, 7.8, 7.8.1, 7.9, 7.11, 7.12, 7.12.1, 8.6, 8.10, 9.1, 9.2.1, 9.2.2, 9.3.2, 9.4, 9.6, 9.8.1, 9.8.2, 9.8.3, 10.2, 10.9.3, 10.10.1.2, 11.1, 11.4.4, 11.4.5, 11.5.1, 11.5.2, 11.5.3, 11.6, 11.6.2, 11.8, 11.8.2, 11.8.5, 11.10.1, 11.10.2, 11.10.3, 12.2.16, 12.3]

### Minor changes

1. Binary string comparisons are always used for conditional compilation. Otherwise, string comparisons would not work because text string comparisons depend on the run-time culture. [3.1.2]
2. Types cannot inherit from a type that is directly or indirectly contained within it. Also clarified the examples. [4.3]
3. Changed the grammar and spec so that enumerated types can use the `System` equivalents of the fundamental types as an underlying type. [7.4]
4. We now allow a conversion between an array of an enumerated type and an array of the underlying type of the enumeration. [8.5, 8.8. 8.9]
5. When overriding a method, you can override it with a `MustOverride` method, causing it to become abstract. [4.5.1]
6. A type member can handle an event in its own class using `Handles`. [9.2.6]
7. Methods and properties that are declared `Overrides` now assume `Overloads`, which is more logical than assuming `Shadows`. [4.3.3]
8. Fields and local variables are allowed to initialize multiple variables at once using the `As``New` syntax. [9.6]
9. Removed the restriction that an inner `Catch` block cannot branch into an outer `Try` block. [10.10.1.2]
10. Classes cannot inherit from `System.MulticastDelegate`. [7.5.1]
11. Shared variables in structures can have initializers. [9.6.3]
12. Added a rule that numeric types are preferred over enumerated types when doing overload resolution against the literal 0. [11.8.1]
13. Array size initializers can explicitly state a lower bound of zero. [9.6.3.3]
14. Added an external checksum directive. [3.4]
15. Array-size initializers on fields are allowed to be non-constant expressions. [9.6.3.3]
16. Keywords with type characters are now treated as identifiers. [2.2]
17. Constants, fields, properties, locals and parameters that have the same name as their type can be interpreted either as the member or the type for the purposes of member lookup. [11.6.1]
18. Added a section talking about types restricted by the .NET Framework and moved discussion of `System.Void` to that section. [7, 7.13]
19. When dealing with a project and a referenced assembly that define the same fully-qualified name, the project's type is preferred, otherwise the name is ambiguous. [4.7.2, 11.4.4]
20. `On``Error` statements do not extend over the call to `New` at the beginning of a constructor. [10.10.2]
21. Resolving an overloaded call to a late bound call is disallowed if the containing type is an interface. [11.8.1]
22. `Overloads` and `Shadows` are not allowed in a standard module. [4.3.3]
23. When looking up in interfaces, a name shadowed in one path through the hierarchy is shadowed in all paths through the hierarchy. Previously, we would give an ambiguity error. [4.3.2]
24. When binding through imports, types and type members are given preference over namespaces. [4.7.2, 11.6]
25. Changing the default property of a type no longer requires `Shadows`. [9.7.3]
26. Unreserved the contextual keywords `Assembly`, `Ansi`, `Auto`, `Preserve`, `Unicode` and `Until`. [2.3]

### Clarifications/Errata

1. Added a note that full-width/half-width equivalence only works on a whole-token basis (i.e. you can't mix it within a token.) [1.1]
2. There are places in the language that allow regular type names but do not allow array type names. Added clarification to the grammar to call these out. [5.2, 7, 7.2, 7.5.1, 7.8.1, 7.9, 9.1, 9.2.5, 10.10.1.2, 11.10.1, 11.10.2, 11.10.3]
3. The spec incorrectly states that colons can only be used as separators at the statement level. In fact, they can be used almost anywhere. Clarified the grammar and spec. [6, 6.2.1, 6.2.2, 6.2.3, 6.3, 6.4.1, 7.2, 7.4, 7.4.1, 7.5, 7.5.1, 7.6, 7.7, 7.8, 7.8.1, 9.2.1, 9.2.2, 9.3, 9.4, 9.5, 9.6, 9.7, 9.7.1, 9.7.2, 10]
4. As a part of the previous bullet point, made labels a statement unto themselves and fixed up the grammar. [10, 10.1]
5. Narrowed the scope of the grammar for delegate declarations to be more accurate. [7.10]
6. Array covariance also includes interface implementation in addition to inheritance. [8.5]
7. When implementing an interface or handling an event, identifiers after a period can match keywords. [9.1, 9.2.6]
8. Split `MustOverride` declarations out from regular method and property declarations. [9.2.1, 9.7]
9. The grammar was wrong for variable declarations – `Dim` is a regular modifier, and not a separate element. [9.6]
10. Spelled out how attributes on `WithEvents` fields are transmitted to the underlying synthetic members. [9.6.2]
11. Invoking an event won't throw an exception if there are no listeners. [10.5.1]
12. Expanded the `RaiseEvent` section to cover the avoidance of race conditions on raising an event. [10.5.1]
13. Clarified that `RaiseEvent` takes an identifier, not an expression. [10.5.1]
14. Covered a corner case with `Mid` assignment. [10.6.3]
15. Statements after a line `If` are not optional. [10.8.1]
16. Expanded the `Do...Loop` grammar to make it more explicit. [10.9.1]
17. Loop control variables in `For` loops can be of an array type. [10.9.2]
18. The size modifier is not optional in an array creation expression. [11.10.2]
19. Property return types can have attributes [9.7]
20. Split out the interface versions of event, property and method declarations for grammatical clarity. [7.8.2, 9.2, 9.2.1, 9.4, 9.7]
21. `MyClass` and `MyBase` cannot stand alone and are moved to the qualified expression production. [11.4.3, 11.6]
22. `TypeOf...Is` is part of the primary category of operator precedence. [11.12.1]
23. A `Handles` clause can have more than one identifier, but only two identifiers are legal. [9.2.6]
24. Conditional compilation only supports a subset of constant expressions. [3.1]
25. Corrected references to `System.Monitor` to `System.Threading.Monitor`. [10.4]
26. Clarified that a compiler can put declarations into a particular namespace by default. [6.4]
27. Re-throwing an exception (`Throw` with no argument) cannot occur inside of a `Finally` block. [10.10.1.3]
28. A conversion from a type to itself is considered widening. [8.8]
29. Tried to clarify the exact behavior of `DirectCast` a bit better than before. [11.11]
30. The element type of a collection in a `For``Each` statement does not have to have an implicit conversion to the loop control variable/expression: the conversion can be of any kind. [10.9.3]
31. Clarified decimal division behavior. [11.13.6]
32. Clarified that overloaded operators are not considered when converting `Nothing` to an empty string for the `&` operator. Also clarified the same behavior applies to the `Like` operator. [11.15, 11.16]
33. Clarified that operations that have `Object` parameters might result in something other than `Integer`. [11.12.2]
34. Added explicit operator type tables. [11.12.3, 11.13.1, 11.13.2, 11.13.3, 11.13.4, 11.13.5, 11.13.6, 11.13.7, 11.13.8, 11.14, 11.15, 11.16, 11.17, 11.17.1, 11.18]
35. Tried to make the "most specific" rules more clear in intent. [11.8.1]
36. Clarified that shadowing a `ParamArray` method by name and signature hides only that signature, even if the shadowing method matches the unexpanded signature of the `ParamArray` method. [4.3.3]
37. Moved the rule about preferring fewer paramarray matches over more during overload resolution earlier in the process to match compiler (and desired) behavior. [11.8.1, 11.8.2]
38. Array-size initializers and array-element initializers cannot be combined. [9.6.3.3]
39. When specifying bounds on an array creation expression and supplying an array-element initializer, the bounds must be specified using constant expressions. [9.6.3.4]
40. Added a discussion of boxing and unboxing, as well as limitations to our anti-aliasing of boxed types design. [8.6]
41. Tried to clarify an obscure rule about enumerated types and `For` loops with `Object` loop control variables. [10.9.2]
42. Clarified that mucking with the loop control variable during an `Object` loop doesn't change the type of the loop. [10.9.2]
43. Noted that delegates and external methods can use duplicate parameter names. [9.2.5]
44. Interfaces have a widening conversion to `Object`. [8.4, 8.8]
45. Interfaces do not inherit from `Object`. [7.8.1]
46. `Object` is reference type. It is not a type that is "neither a reference type nor a value type." [7]
47. Noted the position of `System.ValueType` and `System.Enum` in the value type hierarchy. [7.1]
48. Called out the primitive type conversions we allow when boxed as `Object`. [8.6]
49. Expanded the explanation of a delegate's members. [7.10]
50. Expanded discussion of implicit locals. [10.1.1, 10.2.1]
51. Clarified how static initializers work. [10.2]
52. Noted which synthetic names are ignored by name binding. [9.4, 9.4.1, 9.7.1, 9.7.2]
53. Exceptions caught in `Try...Catch` blocks store their exceptions in the `Err` object. [10.10.1.2]
54. Called out the presence of the identity conversion. [8]
55. Clarified how late-bound accesses are treated in expression contexts. [11.1, 11.1.1, 11.3, 11.6, 11.8.1, 11.9]
56. Corrected rules on when shared constructors execute. [9.3.2]

### Miscellaneous

1. Changed references to the name of the language from "Microsoft Visual Basic .NET" to "Microsoft Visual Basic." The official name of the language itself is simply "Visual Basic."
2. Moved multi-token punctuators and operators such as `<=` or `>>=` into the lexical grammar for clarity. [2.5, 2.6, 5.2.2, 10.6.2, 10.8.2, 11.14]
3. Removed the `NamespaceOrTypeName` production because it wasn't really needed. [4.7, 6.3.1, 6.3.2, 7]
4. Removed the local variable productions because they were superfluous. [10.2]
5. Consolidated all the productions that just included access modifiers and `Shadows` into a single production. [7, 7.4, 7.5, 7.6, 7.7, 7.8, 7.10]
6. With the advent of a default response file for the command-line, all projects will import `System` by default, so I removed it from all examples. [Too many to count.]
7. Changed the suffix for preprocessing statement productions from `Element` to `Statement` and the prefix for conditional compilation statements from `Conditional` to `CC`. [3.1, 3.1.1, 3.1.2, 3.2, 3.3]
8. Corrected the example in the `Resume` statement section. [10.10.2.3]
9. Added `Protected``Friend` to the modifier production. [4.6]
10. Added some examples to array creation expressions. [11.10.2]

## Version 8.0 to Version 8.0 (2<sup>nd</sup> Edition)

This update covers no language changes, it only includes corrections and errata.

### Minor changes

1. Using `WithEvents` on a type that raises no events is now allowed. [9.6.2]
2. Errors in the number of dimensions in a `ReDim` are caught at compile-time, not run-time. [10.12.1]
3. Constant expressions cannot bind through a `With` context. [11.2]
4. `Optional` parameters cannot be typed as an unconstrained type parameter. [9.2.5.3]
5. The default constructor for a `MustInherit` class is `Protected`, not `Public`. [9.3.1]
6. `TypeOf...Is` will give a compile-time error if the expression can never be of the specified type. [11.5.2]
7. Default constructors will call `InitializeComponent` if emitted into a designer-generated class. [9.3.1]
8. Accessing members of value types through type constraints is not allowed. [4.9.2]
9. Added special boxing/unboxing behavior of `System.Nullable(Of T)`. [8.6]
10. A method can be more applicable than another method even if parameter types don't convert to each other, as long at least one parameter type is more applicable. [11.8.1]
11. `System.ValueType` is searched for members if a `Structure` constraint is specified. [4.9.2]
12. Circularity in structure definition is not allowed. [7.6.1]

### Clarifications/Errata

1. Updated `SubSignature` and `FunctionSignature` to include `Sub` and `Function` keywords so that they appear in delegate productions. [9.2.1]
2. Added missing *InvocationExpression* to the *Expression* production. [11]
3. Removed duplicate *VariableInitializer* production. [9.6.3.4]
4. Removed incorrect statement that `Catch` statements can now specify `Object` as the exception type in a catch. [10.10.1.2]
5. Corrected language about interaction between generic types and `Protected` members. [4.6]
6. Corrected *TypeArityList* production. [11.5.1]
7. Clarified that boxed value types are not copied when they are within any type, not just a boxed value type. [8.6]
8. Corrected *ForEachStatement* production. [10.9.3]
9. Corrected *ConversionOperatorModifier* production. [9.8.3]
10. Corrected *MemberAccessExpression* production to include possible generic parameters. [11.6]
11. External method offsets are specified using `#`, not `@`. [9.2.2]
12. Removed unnecessary *RegularInitializer* production. [9.6.3, 9.6.3.1]
13. Collapsed the operator syntactic productions into a single production, as the actual syntax is more flexible than implied. [9.8, 9.8.1, 9.8.2, 9.8.3]
14. Clarified the use of Boolean expressions in the language. [10.8.1, 10.9.1, 10.9.2, 10.10.1.2]
15. Noted that `Protected` constructors can only be called from the type's constructors or derived types' constructors. [4.6]
16. Noted that default instances can only be created by compiler-generated code. [11.6.2.2]
17. Simplified `Imports` syntax productions for simplicity. [6.3, 6.3.1, 6.3.2]
18. The rules about special types not being on the heap includes calls to instance methods of `Object` and `System.ValueType`. [7.13]
19. Clarified that `ParamArray` signatures are not expanded when doing name hiding. [4.3.3]
20. *EnumDeclaration* takes a *NonArrayTypeName* rather than just a *QualifiedName*. [7.4]
21. Clarified the way that overloaded operators are mapped in and out of Visual Basic. [9.8.1, 9.8.2, 9.8.4]
22. Clarified how binding works with case sensitive languages and declarations distinguished only by case. [4.1]

### Miscellaneous

1. All code samples were reviewed for correctness and updated as needed.

## Version 8.0 (2<sup>nd</sup> Edition) to Version 9.0

This update covers the language changes made between version 8.0 of the language and version 9.0 of the language.

### Major Changes

2. Added extension methods. [9.2.7, 11.6, 11.8]
3. Added partial methods. [9.2.1, 9.2.8, 11.8, 11.10.3, 12.1]
4. Added member initialization to object creation expressions. [9.6, 9.6.3.2, 9.6.3.4, 11.10.1]
5. Added local type inferencing. [6.2, 6.2.2, 6.2.5, 10.2, 10.2.1, 10.9.2, 10.9.3, 10.13]
6. Added anonymous type construction. [11.10.1, 11.10.4]
7. Added lambda expressions and closures. [7.13, 10.10.2.2, 11, 11.1, 11.1.1, 11.5.2, 11.8.1, 11.8.5, 11.10.3, 11.20, 11.20.1]
8. Added expression trees. [11.1.1, 11.8.1, 11.8.5]
9. Allowed delegate-creation expressions to create delegates over signatures that do not exactly match. [11.10.3]
10. Added nullable value types. [2.5, 7, 7.1.1, 7.13, 8.6.1, 8.8, 8.9, 8.11, 9.2.5, 9.6, 9.6.3.2, 9.8, 9.8.3, 10.2, 10.9.2, 11.5.3, 11.10.3, 11.12.3, 11.16, 11.17, 11.19, 11.20]
11. Added query expressions. [11, 11.21, 11.21.1, 11.21.2, 11.21.3, 11.21.4, 11.21.5, 11.21.6, 11.21.7, 11.21.8, 11.21.9, 11.21.10, 11.21.11, 11.21.12, 11.21.13, 11.21.14]
12. Added the conditional operator. [3.1, 11, 11.2, 11.22]
13. Added XML namespace imports. [6.3, 6.3.3, 11.5, 11.5.4]
14. Added XML literal expressions. [2, 2.3, 11, 11.23, 11.23.1, 11.23.2, 11.23.3, 11.23.4, 11.23.5, 11.23.6, 11.23.7, 11.23.8]
15. Added XML member access expressions. [11, 11.10.4, 11.24]

### Minor Changes

1. Added a section clarifying the role of native conversions. [8.12, 11.11]
2. The language now takes into account the `InternalsVisibleToAttribute` attribute. [4.5.1, 4.6, 7.5.2, 7.7.1, 7.12, 9.2.3]
3. Group classes can now collect from multiple types, including generic types. [11.6.2.2]
4. The members of `Object` are available on instances of interfaces, but are implicitly shadowed by the interfaces' members. [7.8.2]
5. Delegate types can now be compared for specificity based on return types in overload resolution. [11.8.1]
6. Type arguments, whether inferred or not, must satisfy constraints for a method to be applicable in overload resolution. [11.8.2]
7. Type argument inference is extended to allow multiple inferences for a type argument to be resolved. [8.13, 11.8.5]
8. Type arguments can be inferred from the return type of an `AddressOf` expression. [11.8.5]

### Clarifications/Errata

1. Changed the terminology of the target of a method/property group to be "target" instead of the more confusing "associated instance expression." [10.6.1, 11.1, 11.1.1, 11.3, 11.4.5, 11.6, 11.8, 11.9, 11.10.3]
2. Clarified that type inference is done before overload resolution. [11.8.1]
3. Clarified how paramarrays participate in overload resolution. [11.8.1, 11.8.2]
4. Added missing rule that prefers more derived over more base methods with identical signatures in overload resolution. [11.8.1]
5. Fixed incorrect rules for choosing "less generic" methods in overload resolution. [11.8.1]
6. Clarified that regular initializers can initialize only on variable at a time. [9.6.3.1]
7. Fixed simple name and qualified name binding to have correct behavior in the presence of type arguments. [4.7.1, 4.7.2, 11.4.4, 11.6]
8. Removed the spurious rule that delegates cannot be created over methods declared `MustOverride`. [11.10.3]
9. Clarified the terminology around late binding and `AddressOf`. [11.4.5]
10. Fixed errors in the handling of arrays in type argument inference. [11.8.5]
11. Clarified type argument inference using constructed types. [11.8.5]
12. Clarified rules around reference conversions. [8.4]
13. Clarified/corrected rules regarding type parameter constraints. [8.8, 8.9, 8.10, 8.12]
14. Clarified that a variable name with an object initializer cannot have an array type modifier. [9.6.3.2]
15. Clarified the behavior of the concatenation operator. [11.16]
16. Clarified/corrected the behavior of Boolean expressions. [11.19]
17. Corrected the incorrect result type of operators on `Boolean` values. [11.13.1, 11.13.2, 11.13.3, 11.13.4, 11.13.5, 11.13.6, 11.13.7, 11.18]
18. Added `IsNot` to the operator precedence table, it has the same precedence as `Is`. [11.12.1]
19. Fixed *CatchStatement* production to indicate the `As` clause can be optional. [10.10.1.2]
20. Fixed *MemberAccessExpression* production so that the period is not optional. [11.6]
21. Corrected the grammar for conditional compilation expressions. [3.1]
22. Reworked type constraints section, clarifying and allowing array covariance in satisfying type constraints. [4.9.2]
23. Corrected that `=` and `<>` cannot be used on `Object` with `Option``Strict`, but `IsNot` can. [6.2.2]
24. Noted that `Date` can be used in constant expressions. [11.2]

### Miscellaneous

1. Removed unneeded *DelegateCreationExpression* production. [11.10, 11.10.3]
2. Changed term from "predefined" to "intrinsic." [8.11, 8.11.1, 8.11.2, 11.12.3, 11.15]
3. Removed all references to "foo," "bar," and "baz" in examples.

## Version 9.0 to Version 10.0

### Major Changes

1. Added automatically implemented properties. [9.7, 9.7.4]
2. Allowed implicit line continuations in some contexts. [2.1.2, 4.9.1, 4.9.2, 5.2, 5.2.2, 6.3, 6.3.1, 6.3.3, 7.2, 7.4.1, 7.8.1, 7.9, 7.12, 9.1, 9.2.1, 9.2.2, 9.2.5, 9.2.6, 9.3, 9.4, 9.4.1, 9.5, 9.6, 9.6.3.3, 9.6.3.4, 9.7, 9.7.2, 9.8, 10.5.1, 10.5.2, 10.6.1, 10.6.3, 10.8.2, 10.9.2, 10.9.3, 10.12.1, 10.12.2, 11.4.2, 11.4.4, 11.5.1, 11.5.2, 11.5.3, 11.5.4, 11.6, 11.8, 11.9, 11.10.1, 11.11, 11.13.3, 11.13.4, 11.13.5, 11.13.6, 11.13.7, 11.13.8, 11.14, 11.15, 11.16, 11.17, 11.17.1, 11.18, 11.20, 11.21.1, 11.21.4, 11.21.5, 11.21.6, 11.21.7, 11.21.8, 11.21.9, 11.21.10, 11.21.11, 11.21.12, 11.21.13, 11.21.14, 11.22, 11.23.2]
3. Added collection initializers and array literals. [9.6, 9.6.3, 9.6.3.3, 9.6.3.4 (deleted), 9.7, 11.1, 11.1.1, 11.10, 11.10.1, 11.10.2, 11.10.4, 11.10.5]
4. Added multi-line lambda expressions that can contain statements and single-line statement lambdas. [11.20]
5. Added generic variance. [4.9.1, 4.9.3, 7.11, 8.4.1, 8.8, 8.9]

### Minor Changes

1. When binding type names, inaccessible types are ignored. [4.7.1, 4.7.2, 11.4.4]
2. Structures are no longer required to have at least one instance variable. [7.6.1]
3. Optional parameters are now allowed to be structures, unconstrained type parameters and reference types. [9.2.5.3]
4. The special application of parenthesis to the return value of a method is further restricted to the situation where there is only one accessible method. [11.8]
5. Loop control variables with an identifier will define a new local identifier if local type inference is being used and the identifier is either undefined or resolves to a type [10.9.2, 10.9.3, 11.4.4]

### Clarifications/Errata

1. Moved multi-token punctuators and operators back into syntactic grammar, as whitespace rules apply to them. [2.5, 2.6, 3.1, 5.2.2, 9.8, 10.6.2, 10.8.2, 11.8, 11.14, 11.18]
2. Fixed production for comparison operators in `Select` statements. [10.8.2]
3. Fixed a number of errors in the productions for properties. [9.7]
4. Fixed error in production for date literals. [2.4.6]
5. Fixed error in XML character reference production. [11.23.4]
6. Corrected assertion that property accessors can have the same access as their containing property. [9.7]
7. Fixed spelling of `Wend` and `Variant` in the keyword table. [2.3]
8. Clarified that reclassification of method pointers and lambda methods takes place anywhere a conversion is made. [11.1.1]
9. Fixed assertion that lambda methods without a contextual type become `Func`—instead they become an anonymous lambda type which can be converted to types like `Func`. [11.1.1]
10. Removed spurious `XMLFragment` and `XmlNames` productions. [11.23, 11.23.1]
11. Corrected `XMLAttribute` production to start with whitespace. [11.23.4]
12. Clarified that implicitly declared locals in lambda expressions are declared in the method containing the expression, not the expression itself. [10.2.1]
13. Corrected type name productions so that generic type names are handled properly. [4.7, 6.4.1, 7, 7.12, 9.2.6, 11.5.1]
14. Cleaned up conversion descriptions and classifications. [8, 8.1, 8.3, 8.4, 8.5, 8.8, 8.9, 8.12, 11.5.2]
15. Corrected the fact that array covariance doesn't just work for inheritance and implementation. [8.5, 8.8, 8.9]
16. Fixed `XMLEncodingNameCharacter` production to include the dash character. [11.23.3]
17. Clarified that string interning may occur (but may not). [2.4.4]
18. Added a section on anonymous delegate conversions. [8.4.2, 8.8, 8.9]
19. Defined the phrase "intrinsic conversion." [8.11]
20. Removed incorrect statement that lines excluded by conditional compilation must be lexically valid. [3.1]
21. Clarified that the return types of an overridden method and the overriding method must match. [4.5.1]
22. Removed incorrect assertion that `Protected` constructors can only be called from within a type's constructors or in constructors of derived types. [4.6]
23. Clarified that structures satisfy a `New` constraint. [4.9.1]
24. Clarified that arrays implement `IList(Of T)` for types that their element type has a widening identity or reference conversion to. [7.9]
25. Clarified that boxed enumerated types can be unboxed to their underlying type. [8.6]
26. Clarified that only intrinsic conversions can be used for optional parameter values. [9.2.5.3]
27. Clarified that local declarations are made implicitly if the name does not resolve to anything else. [10.2.1]
28. Corrected the grammar for argument lists. [5.2.2, 11.8]
29. Clarified the use of `IDispatchConstantAttribute` and `IUnknownConstantAttribute` in argument list matching. [11.8.2.]
30. Corrected the direction of conversion for the parameter types when matching signatures in delegate-creation expressions. [11.10.3]
31. Attempted to clarify the position of the null value in the language. [7.1, 7.3, 8.4, 8.6, 10.10.1.3, 10.12.1, 11.1, 11.1.1, 11.4.1, 11.8.2, 11.14]
32. The type of the expression in a `TryCast` does not have to be a value type. [11.11]
33. `Else If` allows a space. [2.5, 3.2, 10.8.1]
34. Whitespace is allowed by the preprocessor. [3.1]
35. Constant string expressions are evaluated at compile-time. [2.4.4]
36. Clarified nesting of Region directives. [3.3]
37. Clarified that implementing methods must match the return type. [4.4.1]
38. Clarified that enumerated types cannot declare type parameters. [4.9]
39. Clarified which inconsistent combinations of type constraints are disallowed. [4.9.2]
40. Attribute class need not have explicit `AttributeUsage`. [5.1]
41. Positional attribute parameters may be `Optional` or `ParamArray`. [5.2]
42. IdentifierModifiers `?` and `()` may be combined. [7, 9.2.5, 9.6, 10.9.2]
43. Delegate declarations may have attributes and modifiers. [7.10]
44. Nested partial type declarations can occur in non-nested containers. [7.12]
45. Clarified the intrinsic Boolean conversions. [8.2]
46. Handles clauses allow zero-argument delegate relaxation, and allows `MyClass` and `MyBase` when specifing event. [9.2.6, 11.4.3]
47. Statements must start with a keyword or identifier. [10]
48. Inference is always be used for local constant declarations which lack explicit types. [10.2]
49. Clarified treatment of Boolean Expressions. [10.8.1, 10.9.1, 10.10.1.2, 11.19]
50. Multiple `Next` statements are combined into one. [10.9.2, 10.9.3]
51. The collection pattern matches extension methods. [10.9.3]
52. The expression "`Nothing`" has classification "default value" and may be reclassified. [11.1.1, 11.4.1]
53. There are limits on what kind of lambdas may be turned into expression trees. [11.1.1]
54. Object is a valid type for a constant expression.  Coercions to and from the null string are allowed in constants. Clarified that operations on constants must result in a valid type for a constant.. [11.2]
55. Clarified the order of evaluation of invocation arguments. [11.3, 11.8]
56. `TypeArityList` requires parentheses and `Of`. [11.5.1]
57. Member access expressions work on nullable types. [11.6]
58. `E.New` is allowed when `E` is an enumeration. [11.6]
59. Equality and inequality operators are not allowed on `Object` with `Option Strict On`. [11.12.2]
60. Clarified behavior of `AndAlso` and `OrElse` for nullable booleans. [11.17.1]
61. `Join` and `GroupJoin` query operators allow nested `Join` and `GroupJoin` query operators. [11.21, 11.21.5, 11.21.14]
62. Only the `Let` query operator may specify the type of its expression range variable. [11.21]
63. The `Group` clause of the `Group By` query operator is optional. [11.21.12]

## Version 10.0 to Version 11.0

### Major Changes

1. Added support for `Async` and `Iterator` methods, and the `Await` and `Yield` keywords [6.1, 9.2.1, 9.7.5, 10, 10.1, 10.1.1-10.1.3, 10.10.1.1, 10.10.1.2, 10.10.2, 10.11, 10.14, 10.15, 11.1, 11.1.1, 11.8.5, 11.12.1, 11.20, 11.25]
1. Added support for `CallerLineNumber`, `CallerFilePath` and `CallerMemberName` attributes on optional parameters; clarified the other Microsoft-specific special treatment of certain optional parameters [11.8.2]
2. Namespaces can now be declared explicitly to go in the global namespace [6.4.1]

### Minor Changes

3. Added a new tie-breaker rule to overload resolution: if one overload can be called without having to substitute any optional parameter defaults, but another cannot, then prefer the first [11.8.1]
4. `For Each` now creates a fresh copy of the iteration variable on each loop of the iteration [10.9.3]
5. The compiler now permits methods to be declared which differ only in optional parameters, so long as their signatures are different [9.2]
6. Added a new tie-breaker rule to overload resolution: of two applicable generic overloads, prefer the one where the generic type parameter is "deeper" [11.8.1.3]
7. Added support for `IReadOnlyList` and `IReadOnlyCollection` [7.9, 8.8, 8.9, 11.1.1]
8. Events have slightly different codegen in winmd files [9.4.1]
9. Binary operator resolution between `Object` and another type, if there are no intrinsic or user-defined conversions, will now be late-bound rather than an error [11.12.3]

### Clarifications/Errata

1. Corrected rules for overload resolution: renamed "applicability" to "specificity"; if an overload candidate is an exact match, then pick it, without considering further overload resolution rules; corrected the rules for specificity precedence between intrinsic numeric types; clarified that Option Strict is used in overload resolution; corrected the rules by which late-binding is used; clarified that narrowing instance methods will not exclude extension methods; added considerable discussion on Delegate Relaxation Levels which are actually performed at the start of overload resolution rather than as a final tie-breaker; clarified the description of the type-parameter tie-breaker between two extension method candidates; corrected the description of the tie-breaker concerning Sub/Function between AddressOf expressions and delegate types; clarified that applicability also judges generic constraints [11.8.1, 11.8.2]
2. Corrected rules about which numeric type is more specific than another in overload resolution, and described the additional final tie-breaker concerning specificity of parameter types [11.8.1.1]
3. Clarified that the "Key" keyword in `FieldInitializer` is only allowed in anonymous object creation expressions [11.10.1]
4. Fixed the code sample for anonymous object expression [11.10.4]
5. Clarified that invocation statements with argument lists will always treat them as arguments of the invocation, and invocation statements must start with an identifier [10.7]
6. Clarified that collection pattern can bind to shared methods/properties, and Collection initializers can bind to shared Add methods [10.9.3, 11.10.1]
7. Clarified name-lookup rules in "For *identifier* =" and "For Each *identifier* In" statements [10.9.2, 10.9.3]
8. Clarified that nested namespaces are "logical" rather than "lexical" [4.7], and clarified rules for qualified and unqualified type/namespace name lookup [4.7.1, 4.7.2]
9. Corrected extension-method-lookup rules: the compiler searches for extension methods in imported namespaces before searching in enclosing namespaces [11.6.3]
10. Clarified that generic types can be constrained to nested types within the type on which they're defined [7.5.2, 7.6.1, 7.8.2]
11. Clarified rules for Imports Alias: they refer to the type or namespace name itself, rather than using the rules for qualified name resolution; and they cannot be open generic types [6.3.1]
12. Clarified rule for overload resolution: if an overload candidate is an exact match, then pick it, without considering further overload resolution rules [11.8.1]
13. Clarified rules for array conversions based on underlying type of enumeration, and to `IList`, `IReadOnlyList`, `ICollection`, `IReadOnlyCollection`, `IEnumerable` [7.9, 8.5, 8.8, 8.9]
14. Described an ambiguity that was introduced by co- and contra-variance [4.9.3]
15. Clarified rules for conversion of lambdas to non-delegate types, including `Object` and `Delegate` and `MulticastDelegate` [8.4.2]
16. Clarified the list of conversions which are widening and narrowing [8.8, 8.9]
17. Clarified that a method can be both `MustOverride` and `Overrides` [9.2.3]
18. Corrected grammar for `GetTypeExpression` [11.5.1]
19. Corrected grammar for `MemberAccessBase`: it does not include `MyBase` or `Myclass` [11.6]
20. Corrected the rules for applicability precedence between intrinsic numeric types, in overload resolution [11.8.1]
21. An implicit line continuation is allowed after the period in xml.@attr [11.24]
22. Clarified that `add_X` and `remove_X` methods on events cannot be invoked [9.4]
23. Corrected rules about which numeric type is more applicable than another in overload resolution [11.8.1.1]
24. Corrected example of anonymous type [11.10.4]
25. Clarified behavior of short-circuiting Logical Operators with respect to `IsTrue` and `IsFalse` [11.17.1]
26. Clarified exactly when local variables are created inside a loop [10.1.5, 10.9, 10.9.2, 10.9.3]
27. Clarified the definition of "method signature" - it doesn't include method name [4.1.1]
28. Clarified rules by which `ByRef` arguments are done through aliasing or copy-in copy-back [9.2.5.2]
29. Constant type members do use type inference [9.5]
30. Noted the cases where a `GoTo` is not allowed into certain blocks [10.11]
31. Clarified rules under which operator resolution may be late-bound [11.12.2, 11.12.3]
32. Clarified the type rules for nullable optional parameters [9.2.5.3]
33. Clarified that only `Me` (and not `MyClass` or `MyBase`) is a valid instance expression; `MyClass` and `MyBase` are only allowed in member access expressions and in `Handles` clauses [9.2.6, 11.4.3, 11.6]
34. Clarified that widening/narrowing judgments apply to expression reclassification - in particular, lambda reclassification with narrower parameter types is narrowing, as is array literal reclassification with to narrower array element types [11.1.1]
